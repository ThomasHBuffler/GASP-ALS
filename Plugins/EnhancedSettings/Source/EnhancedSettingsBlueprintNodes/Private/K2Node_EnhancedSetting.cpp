// Copyright Epic Games, Inc. All Rights Reserved.

#include "K2Node_EnhancedSetting.h"
#include "AssetRegistry/AssetRegistryModule.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2_Actions.h"
#include "Editor.h"
#include "EditorCategoryUtils.h"
#include "K2Node_AssignmentStatement.h"
#include "K2Node_TemporaryVariable.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "KismetCompiler.h"
#include "Misc/PackageName.h"
#include "Subsystems/AssetEditorSubsystem.h"
#include "Modules/ModuleManager.h"
#include "Styling/AppStyle.h"
#include "EnhancedSetting.h"
#include "K2Node_EnhancedSettingEvent.h"
#include "NodeMetadata.h"
#include "K2Node_GetEnhancedSettingValue.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(K2Node_EnhancedSetting)

#define LOCTEXT_NAMESPACE "K2Node_EnhancedSetting"

class UEnhancedInputEditorSettings;
class UK2Node_EnhancedSettingEvent;
static const FName EnhancedSettingPinName = TEXT("EnhancedSetting");
static const FName GameplayTagPinName = TEXT("SettingTagID");
static const FName ActionValuePinName = TEXT("SettingValue");

UK2Node_EnhancedSetting::UK2Node_EnhancedSetting(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
}

void ForEachEventPinName(const TFunctionRef<void(EEnhancedSettingChangeEvent Event, FName PinName)>& PinLambda)
{
	UEnum* EventEnum = StaticEnum<EEnhancedSettingChangeEvent>();
	for (int32 i = 0; i < EventEnum->NumEnums() - 1; ++i)
	{
		if (!EventEnum->HasMetaData(TEXT("Hidden"), i))
		{
			PinLambda(static_cast<EEnhancedSettingChangeEvent>(EventEnum->GetValueByIndex(i)), *EventEnum->GetNameStringByIndex(i));
		}
	}
}

void UK2Node_EnhancedSetting::AllocateDefaultPins()
{
	PreloadObject(static_cast<UObject*>(EnhancedSetting));

	ForEachEventPinName([this](EEnhancedSettingChangeEvent Event, FName PinName)
	{
		static const UEnum* EventEnum = StaticEnum<EEnhancedSettingChangeEvent>();

		UEdGraphPin* NewPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinName);

		// Mark all triggering exec pins as advanced view except for the commit pin. Most of the time, Most is what users will be using.
		// More advanced input set-ups can use the more advanced pins when they want to! 
		NewPin->bAdvancedView = true;

		NewPin->PinToolTip = EventEnum->GetToolTipTextByIndex(EventEnum->GetIndexByValue(static_cast<uint8>(Event))).ToString();
	});
	
	HideEventPins(nullptr);
	const UEdGraphSchema_K2* Schema = GetDefault<UEdGraphSchema_K2>();
	
	AdvancedPinDisplay = ENodeAdvancedPins::Hidden;

	UEdGraphPin* ValuePin = CreatePin(EGPD_Output, GetValueCategory(EnhancedSetting), GetValueSubCategory(EnhancedSetting), GetValueSubCategoryObject(EnhancedSetting), ActionValuePinName);
	
	Schema->SetPinAutogeneratedDefaultValueBasedOnType(ValuePin);

	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Struct, NAME_None, TBaseStructure<FGameplayTag>::Get(), GameplayTagPinName)->bAdvancedView = true;

	if(EnhancedSetting)
	{
		UEdGraphPin* ActionPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Object, EnhancedSetting->GetClass(), EnhancedSettingPinName);
		ActionPin->DefaultObject = const_cast<UObject*>(Cast<UObject>(EnhancedSetting));
		ActionPin->DefaultValue = EnhancedSetting->GetName();
		ActionPin->bAdvancedView = true;
		Schema->ConstructBasicPinTooltip(*ActionPin, LOCTEXT("EnhancedSettingPinDescription", "The input action that caused this event to fire"), ActionPin->PinToolTip);	
	}
	
	Super::AllocateDefaultPins();
}

void UK2Node_EnhancedSetting::HideEventPins(UEdGraphPin* RetainPin) const
{
	// Hide any event pins that are not supported by this Action's triggers in the advanced view
	ForEachEventPinName([this](EEnhancedSettingChangeEvent Event, FName PinName)
	{
		if (UEdGraphPin* Pin = FindPin(PinName))
		{
			Pin->bAdvancedView = !static_cast<uint8>(Event);
		}
	});
}

EEnhancedSettingChangeEvent UK2Node_EnhancedSetting::GetTriggerTypeFromExecPin(const UEdGraphPin* ExecPin)
{
	static const UEnum* EventEnum = StaticEnum<EEnhancedSettingChangeEvent>();
	
	if(ensure(ExecPin && ExecPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Exec))
	{
		return static_cast<EEnhancedSettingChangeEvent>(EventEnum->GetValueByName(ExecPin->PinName));		
	}
	
	return EEnhancedSettingChangeEvent::None;
}

void UK2Node_EnhancedSetting::PostReconstructNode()
{
	Super::PostReconstructNode();
	HideEventPins(nullptr);
}

void UK2Node_EnhancedSetting::PinConnectionListChanged(UEdGraphPin* Pin)
{
	Super::PinConnectionListChanged(Pin);
	HideEventPins(Pin);
}

bool UK2Node_EnhancedSetting::IsConnectionDisallowed(const UEdGraphPin* MyPin, const UEdGraphPin* OtherPin, FString& OutReason) const
{
	return Super::IsConnectionDisallowed(MyPin, OtherPin, OutReason);
}

FLinearColor UK2Node_EnhancedSetting::GetNodeTitleColor() const
{
	return NodeDefaultColor;
}

FName UK2Node_EnhancedSetting::GetActionName() const
{
	return  EnhancedSetting ? EnhancedSetting->GetFName() : FName();
}

FText UK2Node_EnhancedSetting::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	// TODO: Is Using EnhancedSetting->GetFName okay here? Full Asset path would be better for disambiguation.
	if (TitleType == ENodeTitleType::MenuTitle)
	{
		return FText::FromName(GetActionName());
	}
	else if (CachedNodeTitle.IsOutOfDate(this))
	{
		FFormatNamedArguments Args;
		Args.Add(TEXT("EnhancedSettingName"), FText::FromName(GetActionName()));

		FText LocFormat = LOCTEXT("EnhancedSetting_Name", "EnhancedSetting {EnhancedSettingName}");
		// FText::Format() is slow, so we cache this to save on performance
		CachedNodeTitle.SetCachedText(FText::Format(LocFormat, Args), this);
	}

	return CachedNodeTitle;
}

FText UK2Node_EnhancedSetting::GetTooltipText() const
{
	if (CachedTooltip.IsOutOfDate(this))
	{
		// FText::Format() is slow, so we cache this to save on performance
		FString ActionPath = EnhancedSetting ? EnhancedSetting->GetFullName() : TEXT("");
		CachedTooltip.SetCachedText(
			FText::Format(
				LOCTEXT("EnhancedEnhancedSetting_Tooltip", "Event for when '{0}' triggers.\n\nNote: This is not guaranteed to fire every frame, only when the Action is triggered and the current Input Mode includes 'Game'."),
				FText::FromString(ActionPath)),this);
				/*
				@TODO Implement feature?
				,LOCTEXT("EnhancedEnhancedSetting_Node_Tooltip_Tip", "Tip: Use the 'showdebug enhancedsetting' command while playing to see debug information about Enhanced Input."),
				LOCTEXT("EnhancedEnhancedSetting_Node_SettingsTooltip", "You can change what execution pins are visible by default in the Enhanced Input Editor Preferences.")),this);*/
	}
	return CachedTooltip;
}

FSlateIcon UK2Node_EnhancedSetting::GetIconAndTint(FLinearColor& OutColor) const
{
	static FSlateIcon Icon(FAppStyle::GetAppStyleSetName(), "GraphEditor.Event_16x");
	return Icon;
}

bool UK2Node_EnhancedSetting::IsCompatibleWithGraph(UEdGraph const* Graph) const
{
	// This node expands into event nodes and must be placed in an Ubergraph
	EGraphType const GraphType = Graph->GetSchema()->GetGraphType(Graph);
	bool bIsCompatible = (GraphType == EGraphType::GT_Ubergraph);

	if (bIsCompatible)
	{
		UBlueprint* Blueprint = FBlueprintEditorUtils::FindBlueprintForGraph(Graph);

		UEdGraphSchema_K2 const* K2Schema = Cast<UEdGraphSchema_K2>(Graph->GetSchema());
		bool const bIsConstructionScript = (K2Schema != nullptr) ? UEdGraphSchema_K2::IsConstructionScript(Graph) : false;

		bIsCompatible = (Blueprint != nullptr) && Blueprint->SupportsInputEvents() && !bIsConstructionScript && Super::IsCompatibleWithGraph(Graph);
	}
	return bIsCompatible;
}

UObject* UK2Node_EnhancedSetting::GetJumpTargetForDoubleClick() const
{
	return const_cast<UObject*>(Cast<UObject>(EnhancedSetting));
}

void UK2Node_EnhancedSetting::JumpToDefinition() const
{
	GEditor->GetEditorSubsystem<UAssetEditorSubsystem>()->OpenEditorForAsset(GetJumpTargetForDoubleClick());
}

void UK2Node_EnhancedSetting::ValidateNodeDuringCompilation(class FCompilerResultsLog& MessageLog) const
{
	Super::ValidateNodeDuringCompilation(MessageLog);

	if (!EnhancedSetting)
	{
		MessageLog.Error(*LOCTEXT("EnhancedEnhancedSetting_ErrorFmt", "EnhancedEnhancedSettingEvent references invalid 'null' action for @@").ToString(), this);
	}
}

void UK2Node_EnhancedSetting::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	if(!EnhancedSetting)
	{
		static const FText InvalidActionWarning = LOCTEXT("InvalidEnhancedSettingDuringExpansion", "@@ does not have a valid Input Action asset!!");
		CompilerContext.MessageLog.Warning(*InvalidActionWarning.ToString(), this);
		return;
	}

	if (EnhancedSetting->GetSettingValueType() == EEnhancedSettingValueType::NONE) return;
	
	// Establish active pins
	struct ActivePinData
	{
		ActivePinData(UEdGraphPin* InPin, EEnhancedSettingChangeEvent InTriggerEvent) : Pin(InPin), TriggerEvent(InTriggerEvent) {}
		UEdGraphPin* Pin;
		EEnhancedSettingChangeEvent TriggerEvent;
	};

	TArray<ActivePinData> ActivePins;
	ForEachEventPinName([this, &ActivePins](EEnhancedSettingChangeEvent Event, FName PinName) 
	{
		if (UEdGraphPin* EnhancedSettingPin = FindPin(PinName, EGPD_Output); EnhancedSettingPin && EnhancedSettingPin->LinkedTo.Num() > 0)
		{
			ActivePins.Add(ActivePinData(EnhancedSettingPin, Event));
			// Check if this exec pin is supported!
		
		}
	});

	if (ActivePins.Num() == 0)
	{
		return;
	}

	// Bind all active pins to their action delegate
	const UEdGraphSchema_K2* Schema = CompilerContext.GetSchema();

	auto CreateEnhancedSettingEvent = [this, &CompilerContext, &SourceGraph](UEdGraphPin* Pin, EEnhancedSettingChangeEvent TriggerEvent) -> UK2Node_EnhancedSettingEvent*
	{
		if (!EnhancedSetting)
		{
			return nullptr;
		}

		UK2Node_EnhancedSettingEvent* EnhancedSettingEvent = CompilerContext.SpawnIntermediateNode<UK2Node_EnhancedSettingEvent>(this, SourceGraph);
		EnhancedSettingEvent->CustomFunctionName = FName(*FString::Printf(TEXT("SettingTriggerEvt_%s_%s"), *GetActionName().ToString(), *EnhancedSettingEvent->GetName()));
		EnhancedSettingEvent->EnhancedSetting = EnhancedSetting;
		EnhancedSettingEvent->TriggerEvent = TriggerEvent;
		EnhancedSettingEvent->EventReference.SetExternalDelegateMember(GetDelegateName(EnhancedSetting.Get()->GetSettingValueType()));
		EnhancedSettingEvent->SubsystemClass = *GetScopeSubsystemClassMap().Find(EnhancedSetting->GetEnhancedSettingScope());
		EnhancedSettingEvent->AllocateDefaultPins();
		return EnhancedSettingEvent;
	};
	UK2Node_TemporaryVariable* ActionValueVar = CompilerContext.SpawnIntermediateNode<UK2Node_TemporaryVariable>(this, SourceGraph);
	
	ActionValueVar->VariableType.PinCategory = GetValueCategory(EnhancedSetting);
	ActionValueVar->VariableType.PinSubCategory = GetValueSubCategory(EnhancedSetting);
	ActionValueVar->VariableType.PinSubCategoryObject = GetValueSubCategoryObject(EnhancedSetting);
	ActionValueVar->AllocateDefaultPins();
	
	UK2Node_TemporaryVariable* GameplayTagVar = CompilerContext.SpawnIntermediateNode<UK2Node_TemporaryVariable>(this, SourceGraph);
	GameplayTagVar->VariableType.PinCategory = UEdGraphSchema_K2::PC_Struct;
	GameplayTagVar->VariableType.PinSubCategoryObject = TBaseStructure<FGameplayTag>::Get();
	GameplayTagVar->AllocateDefaultPins();
	
	UK2Node_TemporaryVariable* EnhancedSettingVar = CompilerContext.SpawnIntermediateNode<UK2Node_TemporaryVariable>(this, SourceGraph);
	EnhancedSettingVar->VariableType.PinCategory = UEdGraphSchema_K2::PC_Object;
	EnhancedSettingVar->VariableType.PinSubCategoryObject = EnhancedSetting->GetClass();
	EnhancedSettingVar->AllocateDefaultPins();

	for (ActivePinData& PinData : ActivePins)
	{
		UEdGraphPin* EachPin = PinData.Pin;
		UK2Node_EnhancedSettingEvent* EnhancedSettingEvent = CreateEnhancedSettingEvent(EachPin, PinData.TriggerEvent);

		if (!EnhancedSettingEvent)
		{
			continue;
		}
		
		// Create assignment nodes to assign the action value
		UK2Node_AssignmentStatement* ActionValueInitialize = CompilerContext.SpawnIntermediateNode<UK2Node_AssignmentStatement>(this, SourceGraph);
		ActionValueInitialize->AllocateDefaultPins();
		Schema->TryCreateConnection(ActionValueVar->GetVariablePin(), ActionValueInitialize->GetVariablePin());

		Schema->TryCreateConnection(ActionValueInitialize->GetValuePin(), EnhancedSettingEvent->FindPinChecked(ActionValuePinName));
		// Connect the events to the assign location nodes
		Schema->TryCreateConnection(Schema->FindExecutionPin(*EnhancedSettingEvent, EGPD_Output), ActionValueInitialize->GetExecPin());
		
		UK2Node_AssignmentStatement* GameplayTagInitialize = CompilerContext.SpawnIntermediateNode<UK2Node_AssignmentStatement>(this, SourceGraph);
		GameplayTagInitialize->AllocateDefaultPins();
		Schema->TryCreateConnection(GameplayTagVar->GetVariablePin(), GameplayTagInitialize->GetVariablePin());
		Schema->TryCreateConnection(GameplayTagInitialize->GetValuePin(), EnhancedSettingEvent->FindPinChecked(TEXT("GameplayTagID")));
		
		UK2Node_AssignmentStatement* EnhancedSettingInitialize = CompilerContext.SpawnIntermediateNode<UK2Node_AssignmentStatement>(this, SourceGraph);
		EnhancedSettingInitialize->AllocateDefaultPins();
		Schema->TryCreateConnection(EnhancedSettingVar->GetVariablePin(), EnhancedSettingInitialize->GetVariablePin());
		//Schema->TryCreateConnection(EnhancedSettingInitialize->GetValuePin(), EnhancedSettingEvent->FindPinChecked(TEXT("SourceSetting")));
	
		Schema->TryCreateConnection(ActionValueInitialize->GetThenPin(), GameplayTagInitialize->GetExecPin());
		Schema->TryCreateConnection(GameplayTagInitialize->GetThenPin(), EnhancedSettingInitialize->GetExecPin());
		
		// Move the original event connections to the then pin of the Input Action assign
		CompilerContext.MovePinLinksToIntermediate(*EachPin, *EnhancedSettingInitialize->GetThenPin());

		CompilerContext.MovePinLinksToIntermediate(*FindPin(ActionValuePinName), *ActionValueVar->GetVariablePin());
		CompilerContext.MovePinLinksToIntermediate(*FindPin(GameplayTagPinName), *GameplayTagVar->GetVariablePin());
		CompilerContext.MovePinLinksToIntermediate(*FindPin(EnhancedSettingPinName), *EnhancedSettingVar->GetVariablePin());
	}
}

void UK2Node_EnhancedSetting::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	auto CustomizeEnhancedSettingNodeLambda = [](UEdGraphNode* NewNode, bool bIsTemplateNode, TWeakObjectPtr<const UEnhancedSetting> Setting)
	{
		UK2Node_EnhancedSetting* InputNode = CastChecked<UK2Node_EnhancedSetting>(NewNode);
		InputNode->EnhancedSetting = Setting.Get();
	};

	// Do a first time registration using the node's class to pull in all existing actions
	if (ActionRegistrar.IsOpenForRegistration(GetClass()))
	{
		IAssetRegistry& AssetRegistry = FModuleManager::LoadModuleChecked<FAssetRegistryModule>(TEXT("AssetRegistry")).Get();

		static bool bRegisterOnce = true;
		if (bRegisterOnce)
		{
			bRegisterOnce = false;
			if (AssetRegistry.IsLoadingAssets())
			{
				AssetRegistry.OnFilesLoaded().AddLambda([]() { FBlueprintActionDatabase::Get().RefreshClassActions(StaticClass()); });
			}
		}

		TArray<FAssetData> SettingAssets;
		AssetRegistry.GetAssetsByClass(UEnhancedSetting::StaticClass()->GetClassPathName(), SettingAssets, true);
		for (const FAssetData& SettingAsset : SettingAssets)
		{
			UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
			check(NodeSpawner != nullptr);

			if (FPackageName::GetPackageMountPoint(SettingAsset.PackageName.ToString()) != NAME_None)
			{
				if (const UEnhancedSetting* Setting = Cast<const UEnhancedSetting>(SettingAsset.GetAsset()))
				{
					NodeSpawner->CustomizeNodeDelegate = UBlueprintNodeSpawner::FCustomizeNodeDelegate::CreateStatic(CustomizeEnhancedSettingNodeLambda, TWeakObjectPtr<const UEnhancedSetting>(Setting));
					ActionRegistrar.AddBlueprintAction(Setting, NodeSpawner);
				}
			}
		}
	}
	else if (const UEnhancedSetting* Setting = Cast<const UEnhancedSetting>(ActionRegistrar.GetActionKeyFilter()))
	{
		// If this is a specific UEnhancedSetting asset update it.
		UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
		check(NodeSpawner != nullptr);

		NodeSpawner->CustomizeNodeDelegate = UBlueprintNodeSpawner::FCustomizeNodeDelegate::CreateStatic(CustomizeEnhancedSettingNodeLambda, TWeakObjectPtr<const UEnhancedSetting>(Setting));
		ActionRegistrar.AddBlueprintAction(Setting, NodeSpawner);
	}
}

FText UK2Node_EnhancedSetting::GetMenuCategory() const
{
	static FNodeTextCache CachedCategory;
	if (CachedCategory.IsOutOfDate(this))
	{
		// FText::Format() is slow, so we cache this to save on performance
		CachedCategory.SetCachedText(LOCTEXT("EnhancedSettingMenuCategory", "Enhanced Settings|Events"), this);
	}
	return CachedCategory;
}

FBlueprintNodeSignature UK2Node_EnhancedSetting::GetSignature() const
{
	FBlueprintNodeSignature NodeSignature = Super::GetSignature();
	NodeSignature.AddKeyValue(GetActionName().ToString());

	return NodeSignature;
}

TSharedPtr<FEdGraphSchemaAction> UK2Node_EnhancedSetting::GetEventNodeAction(const FText& ActionCategory)
{
	// TODO: Custom EdGraphSchemaAction required?
	TSharedPtr<FEdGraphSchemaAction_K2InputAction> EventNodeAction = MakeShareable(new FEdGraphSchemaAction_K2InputAction(ActionCategory, GetNodeTitle(ENodeTitleType::EditableTitle), GetTooltipText(), 0));
	EventNodeAction->NodeTemplate = this;
	return EventNodeAction;
}

FName UK2Node_EnhancedSetting::GetDelegateName(EEnhancedSettingValueType SettingValueType)
{
	switch (SettingValueType)
	{
	default: return FName(TEXT("EnhancedSettingHandlerDynamicSignature__DelegateSignature"));

	case EEnhancedSettingValueType::Boolean: return FName(TEXT("EnhancedSettingHandlerBoolSignature__DelegateSignature"));
	case EEnhancedSettingValueType::Integer: return FName(TEXT("EnhancedSettingHandlerIntSignature_DelegateSignature"));
	case EEnhancedSettingValueType::Float: return FName(TEXT("EnhancedSettingHandlerFloatSignature__DelegateSignature"));
	case EEnhancedSettingValueType::Color: return FName(TEXT("EnhancedSettingHandlerColorSignature__DelegateSignature"));
	case EEnhancedSettingValueType::Tag: return FName(TEXT("EnhancedSettingHandlerTagSignature__DelegateSignature"));
	}
	
}


#undef LOCTEXT_NAMESPACE

